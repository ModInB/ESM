---
title: "Get Started with ESM Package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get Started with ESM Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Loading the needed packages

```{r setup}
library(ESM)
library(terra)
```

## Case 1: Modeling with presence and absence data

### Data preparation

Here we first need to load our data. To realize an ESM, we first gather some information: the coordinates of the observations (called xy); a response vector (resp) attributing 1 if the species was present or 0 if absent; the name of the species (sp.name) and; environmental predictors (env), which can be a SpatRaster from terra package or a data.frame.

Let's focus here to model the distribution of *Solenostoma gracillimum*, which were only found 14 times out of 413 plots, in the Western Swiss Alps. Here, we will use 4 predictors Ecological indicator values reflecting Soil pH (ch_edaphic_eivdescombes_pixel_r); Annual solar radiation (sradY); Isothermalithy (bio3_tiso_8110_LV95); and Precipitation Seasonality (bio15_ps_8110_LV95). Species data are from Collart et al (2024. *STOTEN*). Environmental variables were gathered from different sources listed in Collart et al (2024).

We first need to download and prepare our data :

```{r}
set.seed(123)
## Species information with environmental values
data("ESM_Species.Env") 

## SpatRaster with 5 environmental predictors
data("ESM_Env")


sp.name <- "Solenostoma_gracillimum" 
xy <- ESM_Species.Env[,1:2] # coordinates
resp <- ESM_Species.Env[,sp.name] # Presence/Absence

env  <- terra::unwrap(ESM_Env) 

```

Let's take a look at our data while plotting the observations across the study area

```{r echo=TRUE, warning=FALSE}
terra::plot(terra::subset(env, 1), col = "grey85", 
            legend = FALSE, box = FALSE, axes = FALSE)
terra::points(xy[resp ==0,], pch = 13, col = "firebrick")
terra::points(xy[resp ==1,], pch = 16, col = "black")
```

### Modeling Core

The first step to model species distribution is to select the modelling technique you will used. With the package ESM, you can modify the parameters of 5 of the 6 modelling techniques available, with the function *ESM_Models.Options*. For this example, we will perform GLM with a binomial family, allowing linear and quadratic terms and performing a step AIC to select the best structure.

```{r echo=TRUE}
mod.options <- ESM_Models.Options(GLM = list(type = "quadratic",
                                             test = 'AIC'))
```

Once the modelling technique is selected, the next step is to generate bivariate models using the function *ESM_Modeling*, allowing by default all the possible pairs of predictors. The pooling procedure is applied directly to evaluate each bivariate models as recommended in Collart & Guisan (2023. *Ecol. Inform.*) with the argument 'pooling = TRUE'. As the Boyce Index is biased with a low prevalence, the Smooth Continuous Boyce Index (SBI) can be computed as a mean across 5 smoothing methods developed in Liu et al (2024. *Ecography*) with the argument 'SBI = TRUE'.

```{r}
my.ESM <- ESM_Modeling(resp = resp,
                       xy = xy,
                       env = env,
                       sp.name = sp.name,
                       models = c("GLM"),
                       models.options = mod.options,
                       prevalence = 0.5,
                       cv.method = "split-sampling",
                       cv.rep = 3, # Usually >= 10
                       cv.ratio = 0.7,
                       pooling = TRUE,
                       SBI = TRUE,
                       parallel = FALSE,
                       n.cores = 1,
                       save.models = FALSE,
                       save.obj = FALSE,
                       # set verbose = TRUE to see the progression
                       verbose = FALSE) 
```

Once the models are generated, *ESM_Modeling* also calculates the predictions and the evaluation of the calibration and the transferability of all the bivariate models, resulting from the pooling evaluation (Collart et al. 2023. *Ecol. Inform.*) :

```{r}
# Prediction for one bivariate model
head(my.ESM$biva.predictions$bio15_ps_8110_LV95.sradY)

# Is the model able to correctly predict the probability of occurrence inside 
# the environment in which it was calibrated (70% of our data if ratio = 0.7).
my.ESM$biva.calibration 

# Is the model able to correctly predict the probability of occurrence of new 
# points based on new environmental data (30% of our data if ratio = 0.7).
my.ESM$biva.evaluations
```

Finally, you can use the function *ESM_Projection* to predict new probability of occurrence of *Solenostoma gracillimum* in a completely new environment (the totality of our map). The function will produce raster maps (.tif) that will be stored in a new folder of your computer.

```{r}
proj <- ESM_Projection(ESM.Mod = my.ESM, 
                       new.env = env,
                       name.env = "current", 
                       parallel = FALSE,
                       save.obj = FALSE,
                       verbose = FALSE)
#load all the maps from the new folder
Proj_TS <- rast(list.files("ESM.output_Solenostoma_gracillimum/current/", 
                           full.names=T)) 

plot(Proj_TS[[1]]) #plot the fmap base on the first bivariate model
```

Now, in practice, you will not use these bivariate models to make predictions. The objective of the ESMs is to generate bivariate models to overcome the overfitting problem related to the low number of occurrences and then combine them. To do so, you will have to use the function *ESM_Ensemble.Modeling* that will generates an ensemble model combining all the bivariate ones based on their respective performances.

In this case, the max TSS was chosen to represent the performance of each model as we are in a Presence/Absence case but you're free the chose any other metrics.

```{r}
my.ESM_EF <- ESM_Ensemble.Modeling(my.ESM, 
                                   weighting.score=c("MaxTSS"), 
                                   threshold=0,
                                   save.obj = FALSE)
## Performances of the ensemble based on the pooling evaluation
my.ESM_EF$evaluations
```

The function *ESM_Response.Plot* allows you to visualize the response curves of the studied species to the different variables.

```{r, fig.fullwidth=TRUE}
## 'par' Only needed to build the vignette
par(mar=c(2, 3, 3, 1) + 0.1)  
## get the response plots of ESMs
my.ESM_responsePlot <- ESM_Response.Plot(my.ESM,my.ESM_EF, 
                                         fixed.var.metric = 'mean',
                                         cex.main = 0.8,
                                         cex.axis= 0.8,
                                         cex.lab =0.8) 


```


```{r, echo = FALSE}
par(mar=c(5, 4, 4, 2) + 0.1)
```

Then, as above, the function *ESM_Ensemble.Projection* will allow you to predict new probability of occurrence for our species of interest based on the ensemble model which combine all the variables in our environment.

```{r}
Ens.proj <- ESM_Ensemble.Projection(ESM.proj = proj,
                                    ESM.ensembleMod = my.ESM_EF,
                                    save.obj = FALSE)

plot(Ens.proj)
```

Secondly, you can determine a threshold that will set the limit between your presences and absences among the probabilities of occurrence using the function *ESM_thresholds*. Once the different possible thresholds are determine, you can project a binary map based on one of these using *ESM_Binarize*. In this case, the one based on the max MCC of calibrated ESMs into a new space was used.

```{r}

my.ESM_thresholds <- ESM_Threshold(my.ESM_EF)

my.ESM_EFproj_current_binary <- ESM_Binarize(Ens.proj, 
                                             1000*my.ESM_thresholds$MCC.th)
plot(my.ESM_EFproj_current_binary)
```

Finally, you can analyse the proportional contribution of the variable in the final ensemble model by using the *ESM_Variable.Contributions* function. As value of higher than 1 indicates that the focal variable has a higher contribution than average.

```{r}
## get the variable contributions of ESMs
ESM_Variable.Contributions(my.ESM, my.ESM_EF)
```

```{r, echo = FALSE}
## remove folder
unlink("ESM.output_Solenostoma_gracillimum",recursive = TRUE)
```

## Case 2: Modeling with presence-only data

Modelling species distribution based on presence-only is often challenging. For this example, we chose *Splachnum melanocaulon*, an endangered bryophyte species mainly living in Scandinavia. The aim of this study case is to assess the impact of climate change on this endangered species in Scandinavia.

This part of the vignette is not finished yet.

### Data preparation

We first collected observation data based on GBIF for the period 1981-2024 with a coordinate uncertainty less than 500m (doi: 10.15468/dl.a5fhfv).

```{r}
set.seed(123)
## Species information with environmental values
data("ESM_Splachnum.Data") 

## SpatRaster with 5 environmental predictors
data("ESM_Splachnum.Env")


sp.name <- "Splachnum_melanocaulon" 
xy <- ESM_Splachnum.Data[,c("decimalLongitude","decimalLatitude")] # coordinates
colnames(xy) = c("x","y")

env  <- terra::unwrap(ESM_Splachnum.Env) 
## Splitting the SpatRaster between present and future climate data
env.pres <- terra::subset(env,1:4)
env.fut <- terra::subset(env,4:8)
## Rename the future climatic layer to match the name of the present one
names(env.fut) = c("northness","bio1","bio3","bio5")
```

```{r}
BP <- Bp_Sampling(env = env.pres,
                  n.points = 10000,
                  method = "rand.geo",
                  To.plot = TRUE,
                  xy.pres = xy)

## Merge the occurrence data with the background points
xy <- rbind(xy,BP[,1:2])
resp <- rep(c(1,0),times = c(nrow(ESM_Splachnum.Data),nrow(BP)))

```

### Modeling Core

```{r}

my.ESM <- ESM_Modeling(resp = resp,
                       xy = xy,
                       env = env.pres,
                       sp.name = sp.name,
                       models = "ANN",
                       cv.rep = 3,
                       pooling = FALSE,
                       SBI = FALSE, 
                       verbose = FALSE) 
```

```{r}
# Is the model able to correctly predict the probability of occurrence inside 
# the environment in which it was calibrated 
my.ESM$biva.calibration 

# Is the model able to correctly predict the probability of occurrence of new points 
my.ESM$biva.evaluations
```

```{r, fig.fullwidth=TRUE}
my.ESM_EF <- ESM_Ensemble.Modeling(my.ESM, 
                                   weighting.score=c("MaxTSS"), 
                                   threshold=0,
                                   save.obj = FALSE)
## Performances of the ensemble based on the pooling evaluation
my.ESM_EF$evaluations
## 'par' Only needed to build the vignette 
par(mar=c(2, 4, 3, 1) + 0.1)  
Resp.Plot <- ESM_Response.Plot(my.ESM,my.ESM_EF)
## Pooling evaluation
myEval <- ESM_Pooling.Evaluation(ESM.Mod = my.ESM,
                                 ESM.ensembleMod = my.ESM_EF,
                                 EachSmallModels = FALSE)
myEval$ESM.evaluations
```

```{r, echo = FALSE}
par(mar=c(5, 4, 4, 2) + 0.1)
```

```{r}
proj.curr <- ESM_Projection(ESM.Mod = my.ESM, 
                       new.env = env.pres,
                       name.env = "current", 
                       parallel = FALSE,
                       save.obj = FALSE,
                       verbose = FALSE)

```

```{r}
Ens.proj.curr <- ESM_Ensemble.Projection(ESM.proj = proj.curr,
                                    ESM.ensembleMod = my.ESM_EF,
                                    save.obj = FALSE)
names(Ens.proj.curr) = "current"
plot(Ens.proj.curr)
```

Projecting in 2041-2070 according to the scenario UKESM ssp 3-7.0

```{r}
proj.fut <- ESM_Projection(ESM.Mod = my.ESM, 
                       new.env = env.fut,
                       name.env = "future", 
                       parallel = FALSE,
                       save.obj = FALSE,
                       verbose = FALSE)

Ens.proj.fut <- ESM_Ensemble.Projection(ESM.proj = proj.fut,
                                    ESM.ensembleMod = my.ESM_EF,
                                    save.obj = FALSE)
names(Ens.proj.fut) = "UKESM_370"

plot(Ens.proj.fut)
```

You can determine a threshold that will set the limit between your presences and absences among the probabilities of occurrence using the function *ESM_thresholds*. Once the different possible thresholds are determine, you can project a binary map based on one of these using *ESM_Binarize*. In this case, the one based on the max TSS of calibrated ESMs into a new space was used.

```{r}

my.ESM_thresholds <- ESM_Threshold(my.ESM_EF)

my.ESM_EFproj_current_binary <- ESM_Binarize(Ens.proj.curr, 
                                      1000*my.ESM_thresholds$TSS.th)

plot(my.ESM_EFproj_current_binary)
```
```{r}
my.ESM_EFproj_fut_binary <- ESM_Binarize(Ens.proj.fut, 
                                      1000*my.ESM_thresholds$TSS.th)
plot(my.ESM_EFproj_fut_binary)
```


### Output Analyses

Comparison of habitat suitability change
```{r, warning=FALSE}
RangeShift_c <- ESM_Range.Shift.Continuous(proj.curr = Ens.proj.curr,
                                           proj.fut = Ens.proj.fut,
                                           occ.pres = xy[resp==1,],
                                           test.significance = TRUE)
#Plot showing the difference in suitabilities between future and present
# and the change in centroid
terra::plot(RangeShift_c$suitability.Change.Map, 
            col = terrain.colors(100)[100:1])
#circle = present centroid, square = future
terra::points(RangeShift_c$results.All.pixels$centroids,
              pch = c(19,15)) 

#Significant changes in suitability values
RangeShift_c$results.All.pixels$significance.SuitabilityDiff
```


```{r, echo = FALSE}
## remove folder
unlink("ESM.output_Splachnum_melanocaulon",recursive = TRUE)
```
